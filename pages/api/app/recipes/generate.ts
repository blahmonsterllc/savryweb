/**
 * iOS App Recipe Generation Endpoint
 * The iOS app calls this endpoint to generate recipes
 * All processing happens server-side to keep the API key secure
 */

import { NextApiRequest, NextApiResponse } from 'next'
import { verify } from 'jsonwebtoken'
import { prisma } from '@/lib/prisma'
import { generateRecipe } from '@/lib/openai'
import { z } from 'zod'

const generateRecipeSchema = z.object({
  ingredients: z.array(z.string()).optional(),
  cuisine: z.string().optional(),
  dietaryRestrictions: z.array(z.string()).optional(),
  cookingTime: z.number().optional(),
  servings: z.number().optional(),
  difficulty: z.string().optional(),
  budget: z.number().optional(),
})

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' })
  }

  try {
    // Verify iOS app token
    const authHeader = req.headers.authorization
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ message: 'Missing or invalid authorization header' })
    }

    const token = authHeader.substring(7)
    let decoded: any
    
    try {
      decoded = verify(token, process.env.NEXTAUTH_SECRET || 'your-secret-key')
    } catch (error) {
      return res.status(401).json({ message: 'Invalid or expired token' })
    }

    const userId = decoded.userId

    // Validate request body
    const params = generateRecipeSchema.parse(req.body)
    
    // Check if similar recipe exists in commonly generated recipes
    const existingRecipe = await prisma.recipe.findFirst({
      where: {
        autoGenerated: true,
        usageCount: { gte: 5 },
        cuisine: params.cuisine,
        dietaryTags: {
          hasEvery: params.dietaryRestrictions || [],
        }
      },
      orderBy: {
        usageCount: 'desc',
      }
    })

    let recipe
    
    if (existingRecipe && Math.random() > 0.3) {
      // 70% chance to return cached recipe if it's popular
      recipe = existingRecipe
      
      // Increment usage count
      await prisma.recipe.update({
        where: { id: existingRecipe.id },
        data: { usageCount: { increment: 1 } }
      })
      
      // Save reference for this user
      await prisma.savedRecipe.upsert({
        where: {
          userId_recipeId: {
            userId,
            recipeId: recipe.id,
          }
        },
        create: {
          userId,
          recipeId: recipe.id,
        },
        update: {},
      })
    } else {
      // Generate new recipe (server-side only!)
      const generatedRecipe = await generateRecipe(params)
      
      // Save recipe to database
      recipe = await prisma.recipe.create({
        data: {
          userId,
          name: generatedRecipe.name,
          description: generatedRecipe.description,
          ingredients: generatedRecipe.ingredients,
          instructions: generatedRecipe.instructions,
          prepTime: generatedRecipe.prepTime,
          cookTime: generatedRecipe.cookTime,
          servings: generatedRecipe.servings,
          calories: generatedRecipe.calories,
          difficulty: generatedRecipe.difficulty,
          cuisine: generatedRecipe.cuisine,
          dietaryTags: generatedRecipe.dietaryTags || [],
          autoGenerated: true,
          source: 'GENERATED',
          usageCount: 1,
        }
      })
    }

    return res.status(200).json({
      recipe: {
        id: recipe.id,
        name: recipe.name,
        description: recipe.description,
        ingredients: recipe.ingredients,
        instructions: recipe.instructions,
        prepTime: recipe.prepTime,
        cookTime: recipe.cookTime,
        servings: recipe.servings,
        calories: recipe.calories,
        difficulty: recipe.difficulty,
        cuisine: recipe.cuisine,
        dietaryTags: recipe.dietaryTags,
      },
      cached: !!existingRecipe,
    })
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ message: 'Invalid input', errors: error.errors })
    }
    
    console.error('iOS recipe generation error:', error)
    return res.status(500).json({ message: 'Failed to generate recipe' })
  }
}







