import type { NextApiRequest, NextApiResponse } from 'next'
import { z } from 'zod'
import { db } from '@/lib/firebase'
import { verifyJWT } from '@/lib/auth'
import { Timestamp } from 'firebase-admin/firestore'

const ingredientSchema = z.union([
  z.string().min(1),
  z.object({
    name: z.string().min(1),
    quantity: z.string().optional(),
    unit: z.string().optional(),
    // Optional shopping/deal metadata (safe to store; ignored by most UIs)
    price: z.number().optional(),
    store: z.string().optional(),
    onSale: z.boolean().optional(),
    aisle: z.string().optional(),
    section: z.string().optional(),
  }),
])

const createRecipeSchema = z.object({
  name: z.string().min(1),
  description: z.string().optional().nullable(),
  ingredients: z.array(ingredientSchema).min(1),
  instructions: z.array(z.string().min(1)).min(1),
  prepTime: z.number().int().min(0).optional().nullable(),
  cookTime: z.number().int().min(0).optional().nullable(),
  servings: z.number().int().min(1).optional().nullable(),
  calories: z.number().int().min(0).optional().nullable(),
  difficulty: z.string().optional().nullable(),
  cuisine: z.string().optional().nullable(),
  dietaryTags: z.array(z.string()).optional().default([]),
  imageUrl: z.string().url().optional().nullable(),
  estimatedCost: z.number().min(0).optional().nullable(),
})

const listSchema = z.object({
  limit: z.coerce.number().int().min(1).max(50).optional().default(20),
  cursor: z.string().optional(), // ISO date string for updatedAt
})

function requireBearer(req: NextApiRequest): string {
  const authHeader = req.headers.authorization
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    throw new Error('Missing Authorization header')
  }
  return authHeader.substring(7)
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'GET' && req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' })
  }

  try {
    const token = requireBearer(req)
    const { userId } = await verifyJWT(token)

    if (req.method === 'POST') {
      const params = createRecipeSchema.parse(req.body)

      const now = Timestamp.now()
      const recipeRef = db.collection('recipes').doc()

      await recipeRef.set({
        userId,
        name: params.name,
        description: params.description ?? null,
        ingredients: params.ingredients,
        instructions: params.instructions,
        prepTime: params.prepTime ?? null,
        cookTime: params.cookTime ?? null,
        servings: params.servings ?? null,
        calories: params.calories ?? null,
        difficulty: params.difficulty ?? null,
        cuisine: params.cuisine ?? null,
        dietaryTags: params.dietaryTags ?? [],
        imageUrl: params.imageUrl ?? null,
        source: 'USER_CREATED',
        autoGenerated: false,
        isPublic: false, // private for now (you can add a "publish" endpoint later)
        usageCount: 0,
        likesCount: 0,
        viewsCount: 0,
        estimatedCost: params.estimatedCost ?? null,
        createdAt: now,
        updatedAt: now,
      })

      const createdDoc = await recipeRef.get()

      return res.status(201).json({
        success: true,
        recipeId: recipeRef.id,
        recipe: {
          id: recipeRef.id,
          ...createdDoc.data(),
        },
      })
    }

    // GET: list user's recipes
    const queryParams = listSchema.parse(req.query)

    let query = db
      .collection('recipes')
      .where('userId', '==', userId)
      .orderBy('updatedAt', 'desc')
      .limit(queryParams.limit)

    if (queryParams.cursor) {
      const cursorDate = new Date(queryParams.cursor)
      if (!Number.isNaN(cursorDate.getTime())) {
        query = query.startAfter(cursorDate)
      }
    }

    const snap = await query.get()
    const recipes = snap.docs.map((d) => ({ id: d.id, ...d.data() }))
    const last = snap.docs[snap.docs.length - 1]
    const lastUpdatedAt = last?.data()?.updatedAt?.toDate?.()

    return res.status(200).json({
      success: true,
      recipes,
      nextCursor: lastUpdatedAt ? lastUpdatedAt.toISOString() : null,
    })
  } catch (error: unknown) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ message: 'Invalid input', errors: error.errors })
    }
    const msg = error instanceof Error ? error.message : String(error)
    if (msg.includes('Missing Authorization')) {
      return res.status(401).json({ message: 'Unauthorized' })
    }
    if (msg.includes('Token')) {
      return res.status(401).json({ message: 'Invalid or expired token' })
    }
    console.error('iOS recipes API error:', error)
    return res.status(500).json({ message: 'Server error', error: msg })
  }
}



